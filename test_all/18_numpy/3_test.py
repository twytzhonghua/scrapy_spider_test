#! /usr/bin/env python
#coding=utf-8
#科学计算中大量使用到矩阵运算，除了数组，NumPy同时提供了矩阵对象（matrix）。
#矩阵对象和数组的主要有两点差别：
#    一是矩阵是二维的，而数组的可以是任意正整数维；
#    二是矩阵的'*'操作符进行的是矩阵乘法，乘号左侧的矩阵列和乘号右侧的矩阵行要相等，而在数组中'*'操作符进行的是每一元素的对应相乘，
#    乘号两侧的数组每一维大小需要一致。数组可以通过asmatrix或者mat转换为矩阵，或者直接生成也可以：

import numpy as np

a = np.arange(20).reshape(4, 5)
a = np.asmatrix(a)
print(a)
print(type(a))
#
#b = np.matrix('1.0 2.0; 3.0 4.0')
#print(b)
#print(type(b))
#


#再来看一下矩阵的乘法，这使用arange生成另一个矩阵b，
#arange函数还可以通过arange(起始，终止，步长)的方式调用生成等差数列，注意含头不含尾。

b = np.arange(2, 45, 3).reshape(5, 3)
b = np.mat(b)
print(b)
print(type(b))


#有人要问了，arange指定的是步长，如果想指定生成的一维数组的长度怎么办？好办，"linspace"就可以做到：
c = np.linspace(0, 2, 9)
print(c)

#回到我们的问题，矩阵a和b做矩阵乘法：

d = a * b
print ("matrix d:", d)

#matrix a:
#[[ 0  1  2  3  4]
# [ 5  6  7  8  9]
# [10 11 12 13 14]
# [15 16 17 18 19]]
#matrix b:
#[[ 2  5  8]
# [11 14 17]
# [20 23 26]
# [29 32 35]
# [38 41 44]]
#matrix c:
#[[ 290  320  350]
# [ 790  895 1000]
# [1290 1470 1650]
# [1790 2045 2300]]



####五、数组元素访问

#数组和矩阵元素的访问可通过下标进行，以下均以二维数组（或矩阵）为例：

a = np.array([[3.2, 1.5], [2.5, 4]])
print(a[0][1])
print(a[0, 1])
#ret
#1.5
#1.5




#可以通过下标访问来修改数组元素的值：


b = a
a[0][1] = 2.0
print ("a:", a)
print ("b:", b)
# ret
#a:
#[[ 3.2  2. ]
# [ 2.5  4. ]]
#b:
#[[ 3.2  2. ]
# [ 2.5  4. ]]
#
#现在问题来了，明明改的是a[0][1]，怎么连b[0][1]也跟着变了？这个陷阱在Python编程中很容易碰上，
#其原因在于Python不是真正将a复制一份给b，而是将b指到了a对应数据的内存地址上。想要真正的复制一份a给b，可以使用copy：

a = np.array([[3.2, 1.5], [2.5, 4]])
b = a.copy()
a[0][1] = 2.0
print ("a:", a)
print ("b:", b)

#ret 
#a: [[ 3.2  2. ]
# [ 2.5  4. ]]
#b: [[ 3.2  1.5]
# [ 2.5  4. ]]


#利用':'可以访问到某一维的全部数据，例如取矩阵中的指定列：

a = np.arange(20).reshape(4, 5)
print ("a:", a)
print( "the 2nd and 4th column of a:")
print ("a[:,[1,3]]:\n", a[:,[1,3]]) # 第1和第3列

#ret
#a: [[ 0  1  2  3  4]
# [ 5  6  7  8  9]
# [10 11 12 13 14]
# [15 16 17 18 19]]
#the 2nd and 4th column of a:
#a[:,[1,3]]:
# [[ 1  3]
# [ 6  8]
# [11 13]
# [16 18]]
#
#稍微复杂一些，我们尝试取出满足某些条件的元素，这在数据的处理中十分常见，
#通常用在单行单列上。下面这个例子是将第一列大于5的元素（10和15）对应的第三列元素（12和17）取出来：
##

print ("ret = ", a[:, 2][a[:, 0] > 5])

#可使用where函数查找特定值在数组中的位置：

loc = np.where(a==11)
print(loc)
#print(a[loc[0][0], loc[1][0]])




